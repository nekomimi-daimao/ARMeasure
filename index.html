<!DOCTYPE html>
<html>
<head>
    <title>AR Measure</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js'></script>
    <!-- 画面スライドでブロックを回転させるためのカスタムコンポーネント -->
    <script>
        AFRAME.registerComponent('drag-rotate', {
            init: function () {
                this.initialRotation = 0;
                this.initialClientX = 0;
                this.isDragging = false;

                this.onStart = this.onStart.bind(this);
                this.onMove = this.onMove.bind(this);
                this.onEnd = this.onEnd.bind(this);

                // マウスイベント
                this.el.sceneEl.addEventListener('mousedown', this.onStart);
                this.el.sceneEl.addEventListener('mousemove', this.onMove);
                this.el.sceneEl.addEventListener('mouseup', this.onEnd);
                this.el.sceneEl.addEventListener('mouseleave', this.onEnd);

                // タッチイベント (モバイル対応)
                this.el.sceneEl.addEventListener('touchstart', this.onStart);
                this.el.sceneEl.addEventListener('touchmove', this.onMove);
                this.el.sceneEl.addEventListener('touchend', this.onEnd);
                this.el.sceneEl.addEventListener('touchcancel', this.onEnd);
            },

            onStart: function (evt) {
                if (evt.button === 0 || (evt.touches && evt.touches.length === 1)) {
                    this.isDragging = true;
                    this.initialClientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
                    this.initialRotation = this.el.getAttribute('rotation').y;
                    evt.preventDefault();
                }
            },

            onMove: function (evt) {
                if (!this.isDragging) { return; }

                const currentClientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
                const deltaX = currentClientX - this.initialClientX;
                const rotationY = this.initialRotation - deltaX * 0.1;

                this.el.setAttribute('rotation', `0 ${rotationY} 0`);
                evt.preventDefault();
            },

            onEnd: function () {
                this.isDragging = false;
            },

            remove: function () {
                this.el.sceneEl.removeEventListener('mousedown', this.onStart);
                this.el.sceneEl.removeEventListener('mousemove', this.onMove);
                this.el.sceneEl.removeEventListener('mouseup', this.onEnd);
                this.el.sceneEl.removeEventListener('mouseleave', this.onEnd);
                this.el.sceneEl.removeEventListener('touchstart', this.onStart);
                this.el.sceneEl.removeEventListener('touchmove', this.onMove);
                this.el.sceneEl.removeEventListener('touchend', this.onEnd);
                this.el.sceneEl.removeEventListener('touchcancel', this.onEnd);
            }
        });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const measureBlock = document.getElementById('measureBlock');
            const outlineBlock = document.getElementById('outlineBlock');
            const inputWidth = document.getElementById('inputWidth');
            const inputHeight = document.getElementById('inputHeight');
            const inputDepth = document.getElementById('inputDepth');
            const displayWidth = document.getElementById('displayWidth');
            const displayHeight = document.getElementById('displayHeight');
            const displayDepth = document.getElementById('displayDepth');
            const axisX = document.getElementById('axisX');
            const axisY = document.getElementById('axisY');
            const axisZ = document.getElementById('axisZ');

            const updateBlockDimensions = () => {
                const width = parseFloat(inputWidth.value);
                const height = parseFloat(inputHeight.value);
                const depth = parseFloat(inputDepth.value);

                // 両方のブロックのジオメトリを更新
                measureBlock.setAttribute('geometry', `primitive: box; width: ${width}; height: ${height}; depth: ${depth}`);
                outlineBlock.setAttribute('geometry', `primitive: box; width: ${width}; height: ${height}; depth: ${depth}`);

                // XYZ軸のサイズと位置を更新
                const axisThickness = 0.02; // 軸の太さ
                const axisExtension = 0.1; // 10cm (0.1m) 延長

                // X軸
                const axisXLength = (width / 2) + axisExtension;
                axisX.setAttribute('geometry', `primitive: box; width: ${axisXLength}; height: ${axisThickness}; depth: ${axisThickness}`);
                axisX.setAttribute('position', `${width / 4 + axisExtension / 2} 0 0`);

                // Y軸
                const axisYLength = (height / 2) + axisExtension;
                axisY.setAttribute('geometry', `primitive: box; width: ${axisThickness}; height: ${axisYLength}; depth: ${axisThickness}`);
                axisY.setAttribute('position', `0 ${height / 4 + axisExtension / 2} 0`);

                // Z軸
                const axisZLength = (depth / 2) + axisExtension;
                axisZ.setAttribute('geometry', `primitive: box; width: ${axisThickness}; height: ${axisThickness}; depth: ${axisZLength}`);
                axisZ.setAttribute('position', `0 0 ${depth / 4 + axisExtension / 2}`);

                // 表示値の更新
                displayWidth.textContent = width.toFixed(1);
                displayHeight.textContent = height.toFixed(1);
                displayDepth.textContent = depth.toFixed(1);
            };

            inputWidth.addEventListener('input', updateBlockDimensions);
            inputHeight.addEventListener('input', updateBlockDimensions);
            inputDepth.addEventListener('input', updateBlockDimensions);

            // 初期ロード時にも寸法を適用
            updateBlockDimensions();
        });
    </script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* スクロールを禁止 */
            margin: 0;
            padding: 0;
        }
        a-scene {
            width: 100%;
            height: 100%;
        }
        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 999;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .ui-container label {
            display: flex;
            align-items: center;
        }
        .ui-container input[type="range"] {
            flex-grow: 1;
            margin: 0 10px;
        }
        .ui-container .value-display {
            width: 50px;
            text-align: right;
        }
    </style>
</head>
<body>
    <!-- UI要素 -->
    <div class="ui-container">
        <label>
            幅 (m):
            <input type="range" id="inputWidth" value="1" min="0.1" max="5" step="0.1">
            <span class="value-display" id="displayWidth">1.0</span>
        </label>
        <label>
            高さ (m):
            <input type="range" id="inputHeight" value="2" min="0.1" max="5" step="0.1">
            <span class="value-display" id="displayHeight">2.0</span>
        </label>
        <label>
            奥行き (m):
            <input type="range" id="inputDepth" value="0.5" min="0.1" max="5" step="0.1">
            <span class="value-display" id="displayDepth">0.5</span>
        </label>
    </div>

    <a-scene vr-mode-ui='enabled: false' embedded arjs>
        <a-camera>
            <!-- ここにARオブジェクトと計測ロジックを追加します -->
            <a-entity
                id="measureBlock"
                material='color: blue; opacity: 0.5; transparent: true'
                geometry='primitive: box; width: 1; height: 2; depth: 0.5'
                position="0 0 -5"
                scale="1 1 1"
                drag-rotate>
                <a-entity
                    id="outlineBlock"
                    material='color: black; wireframe: true'
                    geometry='primitive: box; width: 1; height: 2; depth: 0.5'
                    position="0 0 0"
                    scale="1.02 1.02 1.02">
                </a-entity>
                <a-entity position="0 0 0" render-order="1">
                    <!-- X軸 (赤) -->
                    <a-box id="axisX" color="red" width="0.5" height="0.02" depth="0.02" position="0.25 0 0"></a-box>
                    <!-- Y軸 (緑) -->
                    <a-box id="axisY" color="green" width="0.02" height="0.5" depth="0.02" position="0 0.25 0"></a-box>
                    <!-- Z軸 (青) -->
                    <a-box id="axisZ" color="blue" width="0.02" height="0.02" depth="0.5" position="0 0 0.25"></a-box>
                </a-entity>
            </a-entity>
        </a-camera>
    </a-scene>


</body>
</html>